## Sets - класове

Абстрактен базов клас `Множество` от цели числа, който има:
- `operator[елемент]` - връща булев дали подадения като аргумент елемент принадлежи на множеството.
- `print(stream&)` - изпечатва множеството на съответния поток 

Наследници на това множество са следните конкретни класове:

- `Крайно множество` - елементи се подават като масив в конструктора. **Подсигурете, че няма повтарящи се числа**

- `Множество-интервал` – в конструктора се подават два елемента – граници на интервала. Всички елементи на множеството трябва да са в интервала **(затворен интервал).**

- `Множество по критерий` – в конструктора се подава **предикат (булева функция или клас, който се държи така)**, който определя дали даден елемент принадлежи на множеството.

- `Сечение на множества` – в конструктора се подават две множества. Създаденият обект (сечение) съдържа даден елемент, когато този елемент се съдържа и в двете множества.

- `Обединение на множества` - в конструктора се подават две множества. Създаденият обект (сечение) съдържа даден елемент, когато този елемент се съдържа поне в едно от двете множества.

## Sets - файлова система

Реализирайте програма, която прочита от текстов файл множество от символни низове – имена на **двоични** файлове. Всяко име е разположено на **отделен ред** и съдържа валидно име на файл в съответната файлова система, което представлява едно множество. Съдържание на всеки файл:

- В началото съдържа две 1 число- **arraysCount**.
- След него има **arraysCount** на брой масива от числа. Всеки масив е представен по следния начин: </br>
  {число **numbersCount**(int)} {число **setInfo**(uint8_t)} {**numbersCount** числа(int-ове)} 

Стойността на **setInfo** разглеждаме като поредица от битове, която определя какъв тип множество ще определят тези низове и как ще се добави то към резултата. Най-младшите два бита определят начина на добавяне, а на-старшите три - типа на множеството.

За начин на добавяне разглеждаме три стойности: (не е реализирано)
- `0` – съответното множество замества резултата, без значение на предишни прочетени множества
- `1` – съответното множество се добавя като обединение към получения до момента резултат
- `2` – съответното множество се добавя като сечение към получения до момента резултат

За тип на множествата разглеждаме следните стойности:
- `0` – Файлът описва **крайно** множество. **Елементите са числата**.
- `1` – Файлът описва **множество - интервал**. В този случай **numbersCount задължително трябва да е 2**. Двете последващи числа определят интервала.
- `2` – Файлът описва **множество по критерий**. Негови елементи са **числата, които са сума на някои от подадените numbersCount числа**.
- `3` – Файлът описва **сечение на две множества-интервали**. **numbersCount задължително трябва да е четири**. Две последователни числа във файла описват един интервал и **резултатното множество е сечението им**.
- `4` – Файлът описва **обединение на две множества-интервали**. **numbersCount задължително трябва да е четири**. Две последователни числа във файла описват един интервал и **резултатното множество е обединението им**.

## Sets - печетане през поток
- Крайно множество - `Finite set: {n1,n2,...nk}`
- Множество-интервал - `Interval set: [leftBound : rightBound]`
- Сечение - `Intersection: LHS: [leftBound : rightBound], RHS: [leftBound : rightBound]`
- Обединение - `Union: LHS: [leftBound : rightBound], RHS: [leftBound : rightBound]`
